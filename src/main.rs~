/// This will be a network where weights are sig<<weight instead of sig*weight
/// activations will be the rot_sig_asym (asymmetric sigmoid using bitshifts)
fn main() {
    println!("This is a test of sigmoid activation of 8 bit integer using exclusive bitshift operations.");
    println!("target runtime is 3 clock cycles for 3 barrel shift operations.\n");
    for i in 0..100{
        println!("got: {}",rot_act(i));
    }
    println!("got: {}",rot_act(100));
    println!("got: {}",rot_act(2147483647));
    let x: u32 = 4294967295+72147483647;
    println!("{}", x);
    println!("got: {}",rot_act(2147483647/2));
    //for i in 2147483647/2..2147483647 {
        //println!("got {} for {}", prec_rot_sig_asym(i), i);
        //println!("got {} for {}", rot_act(i), i);
    //}
    /*
    let x = 30;
    let y = rot_sig_asym(x);

    println!("calling rot_sig_asym with {} returned {}", x,y);
    */
}


/// Precision based Asymmetric Sigmoid Function with Bitshifts. 
///
/// Currently only works with positive numbers. negative shifts are platform independant 
/// and therefore unstable. Can implement a domain horizontal shift using (x = x-100) but 
/// this breaks rot schema. Since sums still occur in connections, a -100 may be sufficient if 
/// underflow doesnt occur (floor) but will have 3 cycles+addition ALU cycle. this is probably 
/// vectorized in ALU so must be empirically justified.
///
/// NOTE: CURRENTLY IMPLEMENTING UNSIGNED WITH DOMAIN SHIFT 
///
/// i8 bit precision for i32 bit network to prevent sum overflow and give squashing feature.
/// This lets us pass 32 but operate as if it was 8

//TODO: work out precision domain and range squash
//TODO: if this takes more than 4 shifts its not better than mult.

fn prec_rot_sig_asym(x:i32)-> i32{
    // NOTE: this is only positive half of the sigmoid.
    // TODO: solve for overflow
    //println!("beginning component calculations..\n");
    //let res = x - 100; //uhmmm works but only using half precision (losing MSB set span)
    let res = x;

    //println!("start with: {}", res);
    let res = res >> 5;
    //println!("div shift with {}", res);
    //println!("res/8 = {}",res);
    let res = 1 << res;
    //println!("2^res = {}",res);
    let res = 128 >> res;
    //println!("128/2^res = {}",res);
    //println!("end of component calculations..\n");

    //println!("final: 128/2^(2^(x/32)) = {}", res);
    res
}

/// Saw Function with Bitshifts. 
//TODO: 


///
///
/// built for 32 bit precision squashed to 16 bit precision
///
/// TODO: can this be squashed to half precision, doesnt leave 
/// alot of relative overflow room
///
/// this is actually a really nonlinear activation function and might be interesting. doesnt have
/// good continuity.
fn rot_act(x:u32)->u32{
    //131072 is 2^17
    //65536 2^16
    //2,147,483,647 max 32
    
    //squash to precision
    let res = x >> 1;
    let res = x | res;
    res
}
